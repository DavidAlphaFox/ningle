{"name":"ningle","tagline":"A lightweight web application framework for Common Lisp","body":"# ningle\r\n\r\n[![Build Status](https://travis-ci.org/fukamachi/ningle.svg?branch=master)](https://travis-ci.org/fukamachi/ningle)\r\n\r\n\"ningle\" is a lightweight web application framework for Common Lisp.\r\n\r\n## Usage\r\n\r\n```common-lisp\r\n(defvar *app* (make-instance 'ningle:<app>))\r\n\r\n(setf (ningle:route *app* \"/\")\r\n      \"Welcome to ningle!\")\r\n\r\n(setf (ningle:route *app* \"/login\" :method :POST)\r\n      #'(lambda (params)\r\n          (if (authorize (cdr (assoc \"username\" params :test #'string=))\r\n                         (cdr (assoc \"password\" params :test #'string=)))\r\n              \"Authorized!\"\r\n              \"Failed...Try again.\")))\r\n\r\n(clack:clackup *app*)\r\n```\r\n\r\nNow you can access to http://localhost:5000/ and then ningle should show you \"Welcome to ningle!\".\r\n\r\n## Installation\r\n\r\n    (ql:quickload :ningle)\r\n\r\n## Description\r\n\r\nningle is a fork project of [Caveman](http://fukamachi.github.com/caveman/). ningle doesn't require you to generate a project skeleton.\r\n\r\nAs this is a thin framework, you need to have subtle knowledge about [Clack](http://clacklisp.org). It is a server interface ningle bases on.\r\n\r\n## Getting started\r\n\r\n### Routing\r\n\r\nningle has the [Sinatra](http://www.sinatrarb.com/)-like routing system.\r\n\r\n```common-lisp\r\n;; GET request (default)\r\n(setf (ningle:route *app* \"/\" :method :GET) ...)\r\n\r\n;; POST request\r\n(setf (ningle:route *app* \"/\" :method :POST) ...)\r\n\r\n;; PUT request\r\n(setf (ningle:route *app* \"/\" :method :PUT) ...)\r\n\r\n;; DELETE request\r\n(setf (ningle:route *app* \"/\" :method :DELETE) ...)\r\n\r\n;; OPTIONS request\r\n(setf (ningle:route *app* \"/\" :method :OPTIONS) ...)\r\n```\r\n\r\nRoute pattern may contain \"keyword\" to put the value into the argument.\r\n\r\n```common-lisp\r\n(setf (ningle:route *app* \"/hello/:name\")\r\n      #'(lambda (params)\r\n          (format nil \"Hello, ~A\" (assoc \"name\" params :test #'string=))))\r\n```\r\n\r\nThe above controller will be invoked when you access to \"/hello/Eitaro\" or \"/hello/Tomohiro\", and then `(assoc \"name\" params :test #'string=)` will be \"Eitaro\" and \"Tomohiro\".\r\n\r\nRoute patterns may also contain \"wildcard\" parameters. They are accessible by `(assoc :splat params)`.\r\n\r\n```common-lisp\r\n(setf (ningle:route *app* \"/say/*/to/*\")\r\n      #'(lambda (params)\r\n          ; matches /say/hello/to/world\r\n          (assoc :splat params) ;=> (\"hello\" \"world\")\r\n          ))\r\n\r\n(setf (ningle:route *app* \"/download/*.*\")\r\n      #'(lambda (params)\r\n          ; matches /download/path/to/file.xml\r\n          (assoc :splat params) ;=> (\"path/to/file\" \"xml\")\r\n          ))\r\n```\r\n\r\nRoute matching with Regular Expressions:\r\n\r\n```common-lisp\r\n(setf (ningle:route *app* \"/hello/([\\\\w]+)\" :regexp t)\r\n      #'(lambda (params)\r\n          (format nil \"Hello, ~A!\" (first (assoc :captures params)))))\r\n```\r\n\r\n### Requirements\r\n\r\nRoutes may include a variety of matching conditions, such as the Accept:\r\n\r\n```common-lisp\r\n(setf (ningle:route *app* \"/\" :accept '(\"text/html\" \"text/xml\"))\r\n      #'(lambda (params)\r\n          (declare (ignore params))\r\n          \"<html><body>Hello, World!</body></html>\"))\r\n\r\n(setf (ningle:route *app* \"/\" :accept \"text/plain\")\r\n      #'(lambda (params)\r\n          (declare (ignore params))\r\n          \"Hello, World!\"))\r\n```\r\n\r\nYou can easily define your own conditions:\r\n\r\n```common-lisp\r\n(setf (ningle:requirement *app* :probability)\r\n      #'(lambda (value)\r\n          (<= (random 100) value)))\r\n\r\n(setf (ningle:route *app* \"/win_a_car\" :probability 10)\r\n      #'(lambda (params)\r\n          (declare (ignore params))\r\n          \"You won!\"))\r\n\r\n(setf (ningle:route *app* \"/win_a_car\")\r\n      #'(lambda (params)\r\n          (declare (ignore params))\r\n          \"Sorry, you lost.\"))\r\n```\r\n\r\n### Request & Response\r\n\r\nningle provides two special variables named `*request*` and `*response*`. They will be bound to an instance [Lack.Request](https://github.com/fukamachi/lack/blob/master/src/request.lisp#L33) and [Lack.Response](https://github.com/fukamachi/lack/blob/master/src/response.lisp#L19) for each request.\r\n\r\nFor example, by using them, you can change the response status code, Content-Type or something like that in each controllers.\r\n\r\n### Context\r\n\r\nningle provides an useful function named `context`. It is an accessor to an internal hash table.\r\n\r\n```common-lisp\r\n(setf (context :database)\r\n      (dbi:connect :mysql\r\n                   :database-name \"test-db\"\r\n                   :username \"nobody\"\r\n                   :password \"nobody\"))\r\n\r\n(context :database)\r\n;;=> #<DBD.MYSQL:<DBD-MYSQL-CONNECTION> #x3020013D1C6D>\r\n```\r\n\r\n### Using Session\r\n\r\nningle doesn't provide Session system in the core, but recommends to use [Lack.Middleware.Session](https://github.com/fukamachi/lack/blob/master/src/middleware/session.lisp#L20) with [Lack.Builder](https://github.com/fukamachi/lack/blob/master/src/builder.lisp#L62).\r\n\r\n```common-lisp\r\n(import 'lack.builder:builder)\r\n\r\n(clack:clackup\r\n  (builder\r\n    :session\r\n    *app*))\r\n```\r\n\r\nOf course, you can use other Lack Middlewares with ningle.\r\n\r\n## See Also\r\n\r\n* [Clack](http://clacklisp.org/)\r\n* [Lack](https://github.com/fukamachi/lack)\r\n\r\n## Author\r\n\r\n* Eitaro Fukamachi (e.arrows@gmail.com)\r\n\r\n## Copyright\r\n\r\nCopyright (c) 2012-2014 Eitaro Fukamachi (e.arrows@gmail.com)\r\n\r\n## License\r\n\r\nLicensed under the LLGPL License.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}